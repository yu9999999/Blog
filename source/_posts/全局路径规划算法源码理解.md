---
title: 全局路径规划算法源码理解
date: 2023-10-19 
tags:
- astar
- dijkstra
- 全局路径
categories:
- 机器人路径规划算法
aside: false
---

## 1.设置代价图，更新代价值
cmap=[0,253)->[50,252.4)，cmap=254->254,cmap=255->253，将代价值[0，255]更新为[50,254]
## 2.设置potential数组
将所有potarr设置为最大值。首先封闭地图边缘，将其代价值都设为254（障碍）；然后初始化传播数组；最后将终点的potarr值（行走代价值）置为0，并且将上下左右四个栅格节点放入curP
## 3.通过dijkstra算法以广度优先的方式更新potential数组
利用 v = -0.2301dd + 0.5307d + 0.7040 , pot = ta + hfv公式计算获得的potential分布是以圆的形式向外传播，而直接利用pot = ta+hf这个公式计算获得的potential分布是以方形的形式向外传播，明显以圆的形式向外传播的这种分布方式更结合实际。当设置传播界限时，传播方式是以potential值为边界一步步向外传播，而不设置传播界限时，就是以固定的方形传播方式往外传播，会增加很多额外的不必要传播．所以设置边界能提高传播速度．（可以参考广度优先搜索算法，本身是无向图）

更新potarr：先通过邻居potarr去计算pot，然后对比初始的potarr来对其更新，然后如果邻居不是障碍物就将邻居加入nextpe，当把curpe中的potarr更新完后，再将nextpe全部当作curpe，再去更新potarr，再得到新的nextpe，以此类推循环。这样就会得到目标点到地图所有点的potarr值。当起点的potarr值小于最大默认值时，即说明已经传播到了目标点，此时就可以结束传播过程
## 4.计算轨迹
从目标点开始沿着最优行走代价值梯度下降的方向寻找到起点的最优轨迹。前面计算的potarr都是>50的，因为代价值经过转换是在[50,]范围内


## dijkstra
简单说就是，先设置终点的potarr值为0，其余的点设置为10^10。然后通过算法一步步计算终点到各个点的最小potarr值（因为知道起点的索引，所以当起点的potarr值<10^10时，即找到终点到起点的最小potarr值，则结束）。最后再规划起点到终点的路径（从起点出发，寻找邻居最小的potarr值，然后将其加入全局路径点，直到找到potarr值小于50（只有终点为0<50），至此生成所有路径点。

## astar
看算法与dijkstra差不多，主要区别在于加入nextpe前，pot的计算变为pot+dist(pot是计算该点到终点的potarr最小值，dist是计算该点到起点的代价值)。感觉不是很合理，因为potarr值还是以dijkstra方法计算的，dist是欧式距离，但是potarr值没有将dist加进去。最终的效果感觉应该与dijkstra一样，可能需要自己去写代码或者在基础上去优化，也许我的问题看的不仔细，还需再看看代码。