---
title: 数据结构与算法的理解
date: 2023-11-08
tags:
- 数据结构
categories:
- 数据结构
aside: false
---

# 数据结构
## 逻辑结构：
**线性结构：**一一对应，数组、队列、链表、栈
**非线性结构：**多对多，树、堆、图

## 物理结构：
**顺序存储：**用一组连续的存储单元依次存储数据元素，数据元素之间的逻辑关系由元素的存储位置来表示。数组
例子：(bat,cat,eat,……,mat)
存储：
| … | 
| :----: | 
| bat |
| cat | 
| eat |
| … |


**链式存储：**用一组任意的储存单元储存数据元素，数据元素之间的逻辑关系用指针来表示。
例子：(bat,cat,eat,……,mat)
存储：
| 元素索引 | 元素 | 下一个元素位置索引 | 
| :----: | :----: | :----: |
130| cat | 135 |
135| eat | 170 | 
| … | … | … |
头指针head-> 165| bat | 130 ->下个元素在130号，130单元找到cat|
170| mat | Null ->最后一个元素下一个元素没有了为空|
| … | … | … |


**索引存储：**在储存结点信息同时，还建立附加的索引表。比如手机通讯录，我们可以在手机通讯录上找到一个人名（这里人名就是索引index），点开这个人名，里面就会出现这个人的详细信息（这些信息就是储存的数据）。
**散列（或哈希）存储：**根据结点的关键字直接计算出该结点的储存地址。

## 常用8种数据结构
**数组（Array）** 数组是一种线性结构，而且在物理内存中也占据着一块连续空间。
**队列（Queue）** 队列中的添加和删除数据的操作分别是在两端进行的。队列可以在一端添加元素，在另一端取出元素，也就是：先进先出。
**链表（Linked List）** 链表是物理存储单元上非连续的、非顺序的存储结构，数据元素的逻辑顺序是通过链表的指针地址实现，每个元素包含两个结点，一个是存储元素的数据域 (内存空间)，另一个是指向下一个结点地址的指针域。
**栈（Stack）** 栈也是一种数据呈线性排列的数据结构，不过在这种结构中，我们只能访问最新添加的数据。从栈顶放入元素的操作叫入栈，取出元素叫出栈。
**树（Tree）** 它是由n（n>=1）个有限节点组成一个具有层次关系的集合。把它叫做 “树” 是因为它看起来像一棵倒挂的树，也就是说它是根朝上，而叶朝下的。
**散列表（Hash）** 哈希表，也叫散列表，是根据关键码和值 (key和value) 直接进行访问的数据结构，通过key和value来映射到集合中的一个位置，这样就可以很快找到集合中的对应元素。例如，下列键(key)为人名，value为性别。
**堆（Heap）** 堆是一种图的树形结构，被用于实现“优先队列”(priority queues)。优先队列是一种数据结构，可以自由添加数据，但取出数据时要从最小值开始按顺序取出。在堆的树形结构中，各个顶点被称为“结点”(node)，数据就存储在这些结点中。
**图（Graph）** 图是由结点的有穷集合V和边的集合E组成。其中，为了与树形结构加以区别，在图结构中常常将结点称为顶点，边是顶点的有序偶对，若两个顶点之间存在一条边，就表示这两个顶点具有相邻关系。

# 算法
**冒泡排序：**两个相邻数比较，排序错误就交换位置。由于算法复杂度较高，适合小数据的排序，在数据量大的时候不适合使用。时间：O(n^2^)，空间：O(1)
``` bash
void bubbleSort(int[] arr) {
    int temp = 0;
    for (int i = arr.length - 1; i > 0; i--) { 
        for (int j = 0; j < i; j++) { 
            if (arr[j] > arr[j + 1]) {
                temp = arr[j];
                arr[j] = arr[j + 1];
                arr[j + 1] = temp;
            }
        }
    }
}
```
**选择排序：**从头开始，找到最小值放在开头，然后找第二小的值放在后面，以此类推。适用于简单数据排序。时间：O(n^2^)，空间：O(1)
``` bash
void selectionSort(int[] arr) {
    int temp, min = 0;
    for (int i = 0; i < arr.length - 1; i++) {
        min = i;
        //找到[i,arr.length - 1]最小值
        for (int j = i + 1; j < arr.length; j++) {
            if (arr[min] > arr[j]) {
                min = j;
            }
        }
        //将[i,arr.length - 1]最小值放在位置i处
        if (min != i) {
            temp = arr[i];
            arr[i] = arr[min];
            arr[min] = temp;
        }
    }
}
```
**插入排序：**先将前两个数排序，然后再将第三个数与前两个数比较排序，当前n-1个数排好序后，再将第n个数从n-1的位置开始比较，如果排序错误就交换，以此往前走。适用于数据比较少的时候，一般做为快速排序的扩充。时间：O(n^2^)，空间：O(1)
``` bash
void insertionSort(int[] arr){
    for (int i=1; i<arr.length; ++i){
        int value = arr[i];
        int position=i;
        while (position>0 && arr[position-1]>value){
            arr[position] = arr[position-1];
            position--;
        }
        arr[position] = value;
    }
}
```
**归并排序：**将已有序的子序列合并，得到完全有序的序列；即先使每个子序列有序，再使子序列段间有序。归并排序在数据量比较大的时候也有较为出色的表现（效率上），但是，其空间复杂度O(n)使得在数据量特别大的时候（例如，1千万数据）几乎不可接受。时间：O(nlogn)，空间：O(n)
``` bash
void merge(int* a, int low, int mid, int hight)  //合并函数
{
	int* b = new int[hight - low + 1];  
	int i = low, j = mid + 1, k = 0;    
	while (i <= mid && j <= hight)  
	{
		if (a[i] <= a[j])
		{
			b[k++] = a[i++]; 
		}
		else
		{
			b[k++] = a[j++];
		}
	}
	while (i <= mid) 
	{
		b[k++] = a[i++];
	}
	while (j <= hight)
	{
		b[k++] = a[j++];
	}
	k = 0;  
	for (int i = low; i <= hight; i++) 
	{
		a[i] = b[k++];
	}
	delete[]b;  
}
void mergesort(int* a, int low, int hight) //归并排序
{
	if (low < hight)
	{
		int mid = (low + hight) / 2;
		mergesort(a, low, mid);          
		mergesort(a, mid + 1, hight);   
		merge(a, low, mid, hight);       
	}

```
**快速排序：**1.选取元素的第一个元素作为基准元素；2.从右向左扫描，找到小于等于 pivot 的数，如果找到，将其放置左侧；3.从左向右扫描，找到大于 pivot 的数，如果找到，将其放置右侧；4.重复 步骤二~步骤三，直到 j 与 i 的指针重合，将其作为基准位置返回；5.经过前面步骤，基准左侧值都比基准元素小，右侧都比基准元素大，此时用同样的方法分别将左侧与右侧元素排序。快速排序在大多数情况下都是适用的，尤其在数据量大的时候性能优越性更加明显。时间：O(nlogn)，空间：O(logn)
``` bash
void QuickSort(int a[],int low,int high)//low=0,hign=a.length-1
{
    if(low>=high) return;
    int i = low;
    int j = high;
    int key = a[low];
    while(i<j)//实现第一趟排序
    {
        while(i<j&&key<a[j]) j--;//从右向左找比基准元素小的值
        a[i] = a[j];
        while(i<j&&key>a[i]) i++;//从左向右找比基准元素大的值
        a[j] = a[i];
    }
    a[i] = key;
    QuickSort(a,low,i-1);//左边子序列递归排序
    QuickSort(a,i+1,high);//右边子序列递归排序
}
```
**堆排序：**堆排序在建立堆和调整堆的过程中会产生比较大的开销，在元素少的时候并不适用。但是，在元素比较多的情况下，还是不错的一个选择。尤其是在解决诸如“前n大的数”一类问题时，几乎是首选算法。。时间：O(nlogn)，空间：O(logn)
``` bash
// (最大)堆的向下调整算法
void maxheapdown(int a[], int start, int end)
{
    int c = start;           
    int l = 2*c + 1;     
    int tmp = a[c];           
    for (; l <= end; c=l,l=2*l+1)
    {
        if ( l < end && a[l] < a[l+1])
            l++;       
        if (tmp >= a[l])
            break;       
        else           
        {
            a[c] = a[l];
            a[l]= tmp;
        }
    }
}
void heapsortasc(int a[], int n)
{
    int i;
    for (i = n / 2 - 1; i >= 0; i--)
        maxheap_down(a, i, n-1);
    for (i = n - 1; i > 0; i--)
    {
        swap(a[0], a[i]);
        maxheap_down(a, 0, i-1);
    }
}
```