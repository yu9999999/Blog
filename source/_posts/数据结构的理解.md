---
title: 数据结构与算法的理解
date: 2023-11-08
tags:
- 数据结构
categories:
- 数据结构
---

# 数据结构
**逻辑结构：** 指数据元素之间逻辑关系的数据结构，这里的逻辑关系是指数据元素之间的前后间关系，与数据在计算机中的存储位置无关。
**物理结构：** 指数据的逻辑结构在计算机存储空间中的存放形式称为数据的物理结构，也叫做存储结构。
## 逻辑结构：
**线性结构：** 数据元素之间存在“一对一”的关系，即除了第一个和最后一个数据元素之外，其它数据元素都是首尾相接的，线性结构是一个有序数据元素的集合。比如：一维数组、队列、链表、栈。
**非线性结构：** 数据元素之间是一对多、多对一、多对多的关系。比如：树、堆、图、多维数组（相当于矩阵）。

## 物理结构：
**顺序存储：** 用一组连续的存储单元依次存储数据元素，数据元素之间的逻辑关系由元素的存储位置来表示。比如：数组
例子：(bat,cat,eat,……,mat)
存储：
| … | 
| :----: | 
| bat |
| cat | 
| eat |
| … |


**链式存储：** 用一组任意的储存单元储存数据元素，数据元素之间的逻辑关系用指针来表示。
例子：(bat,cat,eat,……,mat)
存储：
| 元素索引 | 元素 | 下一个元素位置索引 | 
| :----: | :----: | :----: |
130| cat | 135 |
135| eat | 170 | 
| … | … | … |
头指针head-> 165| bat | 130 ->下个元素在130号，130单元找到cat|
170| mat | Null ->最后一个元素下一个元素没有了为空|
| … | … | … |


**索引存储：** 在储存结点信息同时，还建立附加的索引表。比如手机通讯录，我们可以在手机通讯录上找到一个人名（这里人名就是索引index），点开这个人名，里面就会出现这个人的详细信息（这些信息就是储存的数据）。
**散列（或哈希）存储：** 根据结点的关键字直接计算出该结点的储存地址。

## 常用8种数据结构
**数组（Array）** 数组是一种线性结构，而且在物理内存中也占据着一块连续空间。直接通过索引来访问特定的元素，时间复杂度（O(1)）。如果你想在数组的中间插入一个元素，你需要将插入点之后的元素向后移动一位，这需要O(n)的时间复杂度。同样，删除元素也需要将删除点之后的元素向前移动一位，这也需要O(n)的时间复杂度。
``` bash
//定义并初始化数组
int a[] = {1, 3, 5, 4, 6, 7};
//访问特定元素并赋值给x
x = a[1];
//删除数字5
for(int i = 2; i < 6; i++){
  a[i] = a[i+1];
}
//假设上面没有操作，还是调用初始数组，在5后面添加一个数字2
for(int i = 6; i >= 3; i--){
  a[i] = a[i-1];
}
a[3] = 2;
//修改5为2
a[2] = 2;
//c++其他数组模板，也可以理解为类
array<int, 5> arr = { 1, 2, 3, 4, 5 }; //有固定大小
vector<int> arr = {1, 2, 3, 4, 5 };    //可以没有固定大小
valarray<int> arr = { 1, 2, 3, 4, 5 }; //有固定大小
```

**链表（Linked List）** 链表是物理存储单元上非连续的、非顺序的存储结构，数据元素的逻辑顺序是通过链表的指针地址实现，每个元素包含两个结点，一个是存储元素的数据域 (内存空间)，另一个是指向下一个结点地址的指针域。在链表中，每个元素（称为节点）都包含一个数据部分和一个指向下一个节点的指针。这种结构允许我们在常数时间复杂度（O(1)）下插入和删除节点，因为这仅仅涉及到改变一些指针的指向。然而，随机访问链表中的元素需要从链表的头部开始，沿着指针找到目标元素。由于链表不是连续存储的，我们需要遍历链表，直到找到目标元素。因此，随机访问链表中的元素的时间复杂度是O(n)。这里再继续说一下单链表与双链表，单链表只能通过前一个节点next找到下一个节点，而双链表还可以通过后一个节点prev找到前一个节点。
``` bash
//单链表
forward_list<int> fl{ 1,2,3 };
//双链表
list<int> l;
// 使用迭代器遍历列表中的元素  
for (auto it = l.begin(); it != l.end(); ++it) {  
    std::cout << *it << " ";  
} 	
```

**队列（Queue）** 队列中的添加和删除数据的操作分别是在两端进行的。队列可以在一端添加元素，在另一端取出元素，也就是：先进先出。
``` bash
//队列，只能从队首删除元素，队尾插入元素
queue<int>q;  //如果需要访问其他元素，需要不断删除队首元素(pop操作，如果只是遍历保持队列不变，可以在pop前进行push(q.front())操作)
//优先队列，后面的堆将详细介绍
priority_queue<int>pq;
//双端队列，在队首和队尾都可以进行添加删除操作
deque<int>dq;
```
**栈（Stack）** 栈也是一种数据呈线性排列的数据结构，不过在这种结构中，我们只能访问最新添加的数据。从栈顶放入元素的操作叫入栈，取出元素叫出栈。
``` bash
//c++模板
stack<int> q;
```
**树（Tree）** 它是由n（n>=1）个有限节点组成一个具有层次关系的集合。把它叫做 “树” 是因为它看起来像一棵倒挂的树，也就是说它是根朝上，而叶朝下的。
**散列表（Hash）** 哈希表，也叫散列表，是根据关键码和值 (key和value) 直接进行访问的数据结构，通过key和value来映射到集合中的一个位置，这样就可以很快找到集合中的对应元素。
``` bash
//unordered_map可以理解为无序映射
unordered_map<string, int> mymap;
mymap["apple"] = 1; //数组形式插入
pair<string, int> mypair({"banana", 2}); //复制插入
mymap.insert(mypair);
mymap.insert(make_pair("cat", 3)); //移动插入
mymap.insert({{"dog",4}, {"egg",5}}); //初始化数组插入，可以一次性插入多个
unordered_map<string, int> middle = {{"fat",6}, {"great", 7}}; //范围插入
mymap.insert(middle.begin(), middle.end());
for (auto& x : mymap)  //输出
      cout<<x.first<<" : "<<x.second<<endl;
//map可以理解为有序映射
map<string, int> mymap;
```
**堆（Heap）** 堆是一种图的树形结构，被用于实现“优先队列”(priority queues)。优先队列是一种数据结构，可以自由添加数据，但取出数据时要从最小值开始按顺序取出。在堆的树形结构中，各个顶点被称为“结点”(node)，数据就存储在这些结点中。
``` bash
//不写后面两个参数默认为vector，less
priority_queue<int> pq1;
//建立一个优先级队列(大堆)，数据类型是int，利用vector容器实现，less（降序）实现
priority_queue<int, vector<int>, less<int>> pq2;
//建立一个优先级队列(小堆)，数据类型是int，利用vector容器实现，greater（降序）实现
priority_queue<int, vector<int>, greater<int>> pq3;
```
**图（Graph）** 图是由结点的有穷集合V和边的集合E组成。其中，为了与树形结构加以区别，在图结构中常常将结点称为顶点，边是顶点的有序偶对，若两个顶点之间存在一条边，就表示这两个顶点具有相邻关系。个人认为树可以理解成特殊的有向图，因为树中的边都是父节点与子节点的有向传递（如果该关系定义为1，则所有的边都是一条权重为1的有向边）。

# 算法

简单例子看一下普通循环与递归思想
``` bash
void PrintN(int N){
    int i;
    for(i=1;i<=N;i++){
        cout << "%d" << i << endl;
    }
}
//递归
void PrintN(int N){
    if(N){
        PrintN(n-1);
        cout << "%d" << N << endl;
    }
}
```
## 排序算法
**冒泡排序：** 两个相邻数比较，排序错误就交换位置。由于算法复杂度较高，适合小数据的排序，在数据量大的时候不适合使用。时间：O(n^2^)，空间：O(1)
``` bash
void BubbleSort(int a[], int n) {
    int tmp = 0;
    for (int i = n - 1; i > 0; i--) { 
        //两个相邻数比较后判断是否交换，目的是将位置在[0,i]范围内的最大值放在位置i。eg: 5 3 2 6 4 -> 3 2 5 4 6
        for (int j = 0; j < i; j++) {        
            if (a[j] > a[j + 1]) {
                tmp = a[j];
                a[j] = a[j + 1];
                a[j + 1] = tmp;
                //swap(a[j], a[j+1]);
            }
        }
    }
}
```
**选择排序：** 从头开始，找到最小值放在开头，然后找第二小的值放在后面，以此类推。适用于简单数据排序。时间：O(n^2^)，空间：O(1)
``` bash
void SelectionSort(int a[], int n)
{
    for (int i = 0; i < n - 1; i++) {
        int min = i;
        //找位置在[i,n-1]范围的最小值
        for (int j = i + 1; j < n; j++) {
            if (a[j] < a[min])
                min = j;
        }
        //交换位置，将第i小的值放在位置i
        swap(a[min], a[i]);
    }
}
```
**插入排序：** 先将前两个数排序，然后再将第三个数与前两个数比较排序，当前n-1个数排好序后，再将第n个数从n-1的位置开始比较，如果排序错误就交换，以此往前走。适用于数据比较少的时候，一般做为快速排序的扩充。时间：O(n^2^)，空间：O(1)
``` bash
void InsertionSort(int a[], int n){
    //前i个数排好序了，再将第i+1个数插入进去，则前i+1个数就排好序了
    for(int i = 1; i < n; i++){
        if(a[i] < a[i-1]){
            int j = i - 1;
            int tmp = a[i];    //找到a[i]应该插入的位置，再将其插入进去，同时该右移的数右移一步
            while(j >= 0 && tmp < a[j]){
                a[j+1] = a[j];
                j--;
            }
            a[j+1] = tmp;
        }
    }
}
```
**归并排序：** 将已有序的子序列合并，得到完全有序的序列；即先使每个子序列有序，再使子序列段间有序。归并排序在数据量比较大的时候也有较为出色的表现（效率上），但是，其空间复杂度O(n)使得在数据量特别大的时候（例如，1千万数据）几乎不可接受。时间：O(nlogn)，空间：O(n)
``` bash
void Merge(int a[], int low, int mid, int high)  //合并函数。还是下面得例子：merge(a, 0, 1, 3)
{
	int* b = new int[high - low + 1];  
	int i = low, j = mid + 1, k = 0;   
    //第一个while是将左边排好序得数组a[i]和右边排好序得数组a[j]进行比较，并将较小的元素放在数组b中，相应的指针向后移动，直到i>mid或者j>high时结束。
    //1.a[0]与a[2]比较，得到b[0]=a[2]=5；2.将a[0]与a[3]比较，得到b[1]=a[0]=15；3.将a[1]与a[3]比较，得到b[2]=a[3]=25 
	while (i <= mid && j <= high){
		if (a[i] <= a[j])
			b[k++] = a[i++];
		else
			b[k++] = a[j++];
	}
    //由于第一个while已经将左右数组其中一个数组得所有元素比较完了（假设左边数组比较完了），所以第三个while就是将右边数组直接赋值给b，因为本身是排好序的；否则第二个while将左边数组赋值给b。
    //4.由于j=4,i=1，所以最后将a[1]赋值给b[3]
	while (i <= mid){
		b[k++] = a[i++];
	}
	while (j <= high){
		b[k++] = a[j++];
	}
    //5.将排好序的b赋值给a
	k = 0;  
	for (int i = low; i <= high; i++){
		a[i] = b[k++];
	}
	delete[]b;  
}
//归并排序。注意这里的hign不是前面经常出现的n哦，hign=n-1,就是元素个数减一
void MergeSort(int a[], int low, int high) 
//eg:40 15 25 5，low=0，high=3；
//先mergesort(a, 0, 1)计算得：a[0]=15,a[1]=40（中间计算还要经过mergesort(a, 0, 0)，mergesort(a, 1, 1)，merge(a, 0, 0, 1)才得出来的，这里省略了）;
//然后mergesort(a, 2, 3)计算得：a[2]=5,a[3]=25;
//最后merge(a, 0, 1, 3)计算得：a[0]=5,a[1]=15,a[2]=25,a[3]=40。
{
	if (low < high){
		int mid = (low + high) / 2;
		MergeSort(a, low, mid);           
		MergeSort(a, mid + 1, high);   
		Merge(a, low, mid, high);       
	}
}
```
**快速排序：** 1.选取元素的第一个元素作为基准元素；2.从右向左扫描，找到小于等于 pivot 的数，如果找到，将其放置左侧；3.从左向右扫描，找到大于 pivot 的数，如果找到，将其放置右侧；4.重复 步骤二~步骤三，直到 j 与 i 的指针重合，将其作为基准位置返回；5.经过前面步骤，基准左侧值都比基准元素小，右侧都比基准元素大，此时用同样的方法分别将左侧与右侧元素排序。快速排序在大多数情况下都是适用的，尤其在数据量大的时候性能优越性更加明显。时间：O(nlogn)，空间：O(logn)
``` bash
void QuickSort(int a[],int low,int high)  //eg:32，25，5，56，17，33
{
    if(low >= high) return;
    int i = low;
    int j = high;
    int key = a[low];
    while(i < j){
        while(i < j && key < a[j]) j--;//1.从右向左找比基准元素（32）小的值,找到17,此时j=4
        a[i] = a[j];                    //2.a[0]=a[4]=17       此时 17 25 5 56 17 33
        while(i < j && key > a[i]) i++;//3.从左向右找比基准元素（32）大的值,找到56，此时i=3
        a[j] = a[i];                   //4.a[4]=a[3]=56        此时17 25 5 56 56 33
    }
    a[i] = key;                       //5.a[3]=32              此时 17 25 32 56 33
    QuickSort(a, low, i-1);  //左边子序列递归排序，用上面的方法对 17 25排序
    QuickSort(a, i+1, high); //右边子序列递归排序，用上面的方法对 56 33排序
}
```
**堆排序：** 堆排序在建立堆和调整堆的过程中会产生比较大的开销，在元素少的时候并不适用。但是，在元素比较多的情况下，还是不错的一个选择。尤其是在解决诸如“前n大的数”一类问题时，几乎是首选算法。时间：O(nlogn)，空间：O(1)。
``` bash
//最大堆，start是父节点位置，end是最后位置
void Maxheapdown(int a[], int start, int end) //该函数返回父节点、左孩、右孩中最大的值
{
    //建立父节点指标和子节点指标
    int dad = start;
    int son = dad * 2 + 1;  //当前是左孩，比较后更新为孩子中最大值
    while (son <= end){ //若子节点指标在范围内才做比较
        if (son + 1 <= end && a[son] < a[son + 1]) //先比较两个子节点大小，选择最大的
            son++;
        if (a[dad] > a[son]) //如果父节点大于子节点代表调整完毕，直接跳出函数
            return;
        else {              //否则交换父子内容再继续子节点和孙节点比较
            swap(a[dad], a[son]);
            dad = son;
            son = dad * 2 + 1;
        }
    }
}
//堆排序(从小到大)，对数组a进行升序排序，n是数组个数
void HeapSort(int a[], int n)
{
    for (int i = n / 2 - 1; i >= 0; i--){   //构造最大堆，数组顺序就是从上到下，从左到右
        Maxheapdown(a, i, n-1);
    }
    for (int i = n - 1; i > 0; i--){       //最大堆排序方式
        swap(a[0], a[i]);                  //交换元素，将最大元素放在数组最后面，每次交换后都是前面最大值
        Maxheapdown(a, 0, i-1);            //调整最大堆，上一个for很多都调整好了，所以这里只调整根节点那里
    }
}
```
**希尔排序：**1.对于n个待排序的数列，取一个小于n的整数gap(gap被称为步长)将待排序元素分成若干个组子序列，所有距离为gap的倍数的记录放在同一个组中。2.对各组内的元素进行直接插入排序（ 这一趟排序完成之后，每一个组的元素都是有序的）。3.减小gap的值，并重复执行上述的分组和排序。4.重复这样的操作，当gap=1时，整个数列就是有序的。希尔排序没有快速排序快 ，在中等大小规模表现良好，希尔算法在最坏的情况下和平均情况下执行效率相差不是很多，与此同时快速排序在最坏的情况下执行的效率会非常差。时间复杂度与步长相关。
``` bash
void ShellSort(int a[], int n)
{
    int i,j,gap;
    // gap为步长，每次减为原来的一半。
    for (gap = n / 2; gap > 0; gap /= 2){
        for (i = 0 ;i < gap; i++){                //分为gap组
            for (j = i + gap; j < n; j += gap){   //每组排序，就是插入排序的思想，先将前面排好序，后面的插入进来排序
                if (a[j] < a[j - gap]){
                    int tmp = a[j];
                    int k = j - gap;
                    while (k >= 0 && a[k] > tmp){//比如：2 4 8 3，如果没有while则结果为2 4 3 8，有while结果为2 3 4 8
                        a[k + gap] = a[k];
                        k -= gap;
                    }
                    a[k + gap] = tmp;
                }
            }
        }

    }
}
```

**计数排序：**1.找到数据范围；2.计算数据个数；3.依次排序。计数排序只适用于数据范围较集中的序列的排序，若待排序列的数据较分散，则会造成空间浪费，并且计数排序只适用于整型排序，不适用与浮点型排序。
``` bash
//eg: 3 5 8 1 2 2 6 5 4 3 1 2 6 8 5 4
void CountSort(int a[], int n)
{
	//1.首先找出最大值与最小值,max=8,min=1
	int min = a[0];
	int max = a[0];
	for (int i = 0; i < n; i++) {
		if (a[i] > max)
			max = a[i];
		if (a[i] < min)
			min = a[i];
	}
	//2.开辟内存，range=7+1=8,则count初始化为{0,0,0,0,0,0,0,0}代表0的个数为0，1的个数为0，2的个数为0，3的个数为0，4的个数为0，5的个数为0，6的个数为0，7的个数为0
	int range = max - min + 1;
	vector<int>  count(range, 0);
	//3.统计相同元素出现次数，for完过后，count={2，3，2，2，3，2，0，2}
	for (int i = 0; i < n; i++) {
		count[a[i] - min]++;
	}
	//4.排序
	int k = 0;
	for (int j = 0; j < range; j++) {
		for(int m = 0; m < count[j]; m++){
			a[k++] = j + min;  //a[0]=1,a[1]=1，然后退出while，进入for，可以得到a[3]=2,a[4]=2,a[5]=2，再退出while，一直下去
		}
	}
}
```
**桶排序：**1.确定元素范围，以及桶的个数；2.将元素放入桶中，在哪个范围放入哪个桶；3.对每个桶排序；4.最后按桶的顺序就排好序了。他的时间复杂度与排序方式有关。这里只看看桶间排序的思想，桶内排序直接使用上诉算法就行了。
``` bash
void BucketSort(int a[], int n){
    //1.将元素装入桶中
    vector<int> buckets[10];              //假设定义10个桶，桶的个数竟然与元素个数n一样，实际桶的个数应该是元素最大值/size
    int size = 2;                         //一个桶与另一个桶的间隔
    for (int i = 0; i < n; i++){
        int idx = a[i] / size;            //可以计算出a[i]元素属于哪个桶的索引。注意：因为这里直接除以size，所以元素都是>=0的，[0,size-1]属于桶0，[size,2size-1]属于桶1，……
        buckets[idx].push_back(a[i]);     //入桶
    }
    //2.桶内无序，桶间有序，如果需要排好序，可以调用上面的排序算法进行桶间排序
    int l = 0;
    for (int i = 0; i < n; i++) {
        for (int j = 0; j < buckets[i].size(); j++) {
            a[l++] = buckets[i][j];
        }
    }
}
```
**基数排序：**首先将所有待比较数字统一为统一位数长度，接着从最低位开始，依次进行排序。排序后，数列就变成了一个有序序列。这里用了桶排序的思想，因为每次排序都只需要10个桶。
``` bash
void RadixSort(int a[], int n, int max)
{
    //1.计算最大数的位数
    int d = 1;
    while (max) {
        ++d;
        max /= 10;
    }
    //2.d位数就进行d次排序，每次都用桶排序，只需要桶间有序就可以了，桶内无序没关系
    vector<int> buckets[10];   //数字是0-9，所以需要10个桶
    int radix = 1;             //radix=1是个位数排序，radix=10是十位数排序，以此类推
    int m;                     //桶的索引
    for (int i = 1; i <= d; i++)
    { 
        int z = 0;                 //数组排序索引
        //入桶
        for (int j = 0; j < n; j++) {
            m = (a[j] / radix) % 10;
            buckets[m].push_back(a[j]);
        }
        //桶间排序就够了
        for (int k = 0; k < 10; k++) {
            for (int l = 0; l < buckets[k].size(); l++) {
                a[z++] = buckets[k][l];
            }
        }
        radix = radix * 10;
        //每次排序完清空桶
        for (int i = 0; i < 10; ++i) {
            buckets[i].clear();
        }
    }
}
```
## 查找算法 
**顺序查找：** 对于任意一个序列，从一端开始，顺序扫描，依次将扫描到的结点关键字与给定值k相比较，若相等则表示查找成功；若扫描结束仍没有找到关键字等于k的结点，表示查找失败。
``` bash
int SequentialSearch(int a[], int n, int key)
{
    for (int i = 0; i < n; i++)
    {
        if (a[i] == key)
            return i;      //返回位置i
    }
    return -1;             //没找到
}
```
**二分查找：** 1.确定查找范围low=0，high=N-1，计算中项mid=（low+high）/2。2.若mid==x或low>=high,则结束查找；否则，向下继续。3.若$amid<x$,说明待查找的元素值只可能在比中项元素大的范围内，则把mid+1的值赋给low，并重新计算mid，转去执行步骤2；若$mid>x$，说明待查找的元素值只可能在比中项元素小的范围内，则把mid-1的值赋给high，并重新计算mid，转去执行步骤2。(注：必须先排好序)
``` bash
int BinarySearch(int a[], int n, int key)
{
    if (a == NULL || n == 0)
        return -1;
    int low = 0;
    int high = n - 1;
    int mid = 0;

    while (low <= high)
    {
        mid = (low + high) / 2;
        if (a[mid] < key)
            low = mid + 1;
        else if (a[mid] > key)
            high = mid - 1;
        else
            return mid;
    }
    return -1;
}
```
**插值查找：** 类似于二分查找思想，只是计算mid方式不同。mid=low+(key-a[low])/(a[high]-a[low])*(high-low)  （注：仍然有序）
``` bash
int InterpolationSearch(int a[], int n, int key) {
	int left = 0;
	int right = n - 1;
	int mid;
	// 终止条件
	while (left < right)
	{
		// 中间位置计算
		mid = left + int((key - a[left]) / (a[right] - a[left]) * (right - left));
		if (a[mid] == key) {
			return mid;
		}
		// 目标值在中间值右边，更新左位置
		else if (a[mid] < key) {
			left = mid + 1;
		}
		// 目标值在中间值左边，更新右位置
		else
			right = mid - 1;
	}
	// 只剩最后一个元素时
	if (left == right) {
		if (key == a[left]) {
			return left;
		}
	};
	return -1;
}
```
**斐波那契查找：** 也是二分查找的一种提升算法，通过运用黄金比例的概念在数列中选择查找点进行查找，斐波那契数列：{1, 1, 2, 3, 5, 8, 13, 21, 34, 55，……}。
``` bash
//斐波那契数列，a[n]=a[n-1]+a[n-2]，这里就是求第n个数的值a[n]=f
int Fibonacci(int n)
{
	int f = 0, g = 1;
	while (n--)
	{
		g += f;
		f = g - f;
	}
	return f;
}
//eg:1,5,7,12,15,25,84,86,92,99   查找12
int FibonacciSearch(int* a, int n, int key)
{
	int low = 1, high = n, mid, i, k = 0;
	while (n > Fibonacci(k) - 1)k++;                   //1. n=10，则k=7
	for (i = n; i < Fibonacci(k) - 1; i++)a[i] = a[n]; //2. a[10]=a[11]=a[9]=99
	while (low <= high)
	{
		mid = low + Fibonacci(k - 1) - 1;         //3.k=6,mid=8,a[8]=92 5.k=4,mid=3,a[3]=12
		if (key < a[mid])
		{
			high = mid - 1;                  //4.high=7,k=5
			k -= 1;
		}
		else if (key > a[mid])
		{
			low = mid + 1;
			k -= 2;
		}
		else
		{
			if (mid <= n)return mid;        //6.返回mid=3
			else return n;
		}
	}
	return -1;
}
```
**分块查找：** 将n个数据元素”按块有序”划分为m块（m ≤ n）。每一块中的结点不必有序，但块与块之间必须”按块有序”；即第1块中任一元素的关键字都必须小于第2块中任一元素的关键字；而第2块中任一元素又都必须小于第3块中的任一元素，……。1、先选取各块中的最大关键字构成一个索引表；2、查找分两个部分：先对索引表进行二分查找或顺序查找，以确定待查记录在哪一块中；3、在已确定的块中用顺序法进行查找。（如果块内也有序的话，则所有元素都是排好序的，此时也就分成几等份，看查找元素在哪个区间而已）
``` bash
typedef struct{
    int bockts_max;            //bockts_max为块内最大值 
    int link;                 //指向对应块的起始下标 
} IdxType;
typedef IdxType IDX[100];   //索引表类型 

int ChunkSearch(IDX I, int m, int a[], int n, int key){   
    int low = 0, high = m - 1, mid, i;
    int b = n / m;                        //b为每块的记录个数
    //二分查找找属于的块
    while (low <= high)     
    {
        mid = (low + high) / 2;
        if (I[mid].bockts_max >= key)
            high = mid - 1;
        else
            low = mid + 1;
    }
    //找到块后，从块的最小索引开始查找元素位置
    i = I[high + 1].link;           //I[high + 1].link为块中的最小索引
    while (i <= I[high + 1].link + b - 1 && a[i] != key) //没找到，索引就加一。要么找到；要么直到索引进入下一个块，则认为没找到
        i++;
    if (i <= I[high + 1].link + b - 1)
        return i;            //返回查找成功后该数值在数组中的索引
    else
        return -1;
}
//下面就是举的例子
int main() {
    IDX I = { { 14,0 },{ 34,5 },{ 66,10 },{ 85,15 },{ 100,20 } };
    int a[] = { 8,14,6,9,10, 22,34,18,19,31, 40,38,54,66,46, 71,78,68,80,85, 100,94,88,96,87 };
    int target = 5; 
    int index = ChunkSearch(I, 5, a, 25, 22);
    if (index != -1) {
        cout << "Target found at index " << index << endl;
    }
    else {
        cout << "Target not found" << endl;
    }
    return 0;
}
```
**树表查找：** 
**散列表查找：** 

## 贪心算法
**原理：** 贪心算法（又称贪婪算法）是指，在对问题求解时，总是做出在当前看来是最好的选择。也就是说，不从整体最优上加以考虑，算法得到的是在某种意义上的局部最优解。简单说，就是一个大问题分解成几个小问题，几个小问题的最优解的和就是大问题的最优解。举两个例子。
**1.**dijkstar算法，但是该算法求解的最短距离不一定全局最优，因为走的下一个点并不是全局最优经过的点，或者说全局最优的点无法到达局部最优那个点（因为画成了小格子，所以一个点只能到达顶点，但是实际最短路线可能会经过边），举个例：在不考虑障碍物情形下，原点和终点在一个简单的3*4小格子的对角线上，用贪心算法算出来的最短距离为1+3sqrt(2)（这里用的欧氏距离，但是贪心算法必须到达一个顶点） ，实际全局最短距离为5，虽然不是全局最优，但是也算接近。但是如果原点和终点在同一边上，则贪心算法就是全局最优。
**2.**钱币找零问题，假如有15元，需要用11、5、1三种面额的钱币来表示，如果用贪心算法来选择的话，会从11开始选择，这样就会选出一张11面额和4张1元面额的方案，但实际上，用3张5元面额的方案，使用的钱币更少，此时贪心方案就选不出全局最优解。

## 暴力递归
**青蛙问题：** 一只青蛙一次可以跳上1级台阶，也可以跳上2级台阶。求该青蛙跳上一个 10 级的台阶总共有多少种跳法。
**思路：** 要想跳到第10级台阶，要么是先跳到第9级，然后再跳1级台阶上去;要么是先跳到第8级，然后一次迈2级台阶上去，则f(10)=f(9)+(8)。以此类推。
## 动态规划
**原理：** 若要解一个给定问题，我们需要解其不同部分（即子问题），再合并子问题的解以得出原问题的解。 通常许多子问题非常相似，为此动态规划法试图仅仅解决每个子问题一次，从而减少计算量： 一旦某个给定子问题的解已经算出，则将其记忆化存储，以便下次需要同一个子问题解之时直接查表。 这种做法在重复子问题的数目关于输入的规模呈指数增长时特别有用。类似暴力递归，但是这里用空间去换时间。
**青蛙问题思路：** f(1)=1,f(2)=2,f(3)=f(1)+f(2)=3,……,f(n)=f(n-1)+f(n-2)。先储存f(1),f(2),算一个存一个，直到算出f(n)。
**背包问题：** 假设我们有n种类型的物品，分别编号为1, 2...n。其中编号为i的物品价值为vi，它的重量为wi。为了简化问题，假定价值和重量都是整数值。现在，假设我们有一个背包，它能够承载的重量是Cap。现在，我们希望往包里装这些物品，使得包里装的物品价值最大化，那么我们该如何来选择装的东西呢？注意：每种物品只有一件，可以选择放或者不放。初始化数据为：n=5，w={2,2,6,5,4}，v={6,3,5,4,6}，Cap=10
**背包思路：** f[i][j]=max(f[i-1][j],f[i-1][j-w[i]]+p[i])，i代表子问题，j代表承重，f(i)(j)代表第i个问题下满足承重j下的最优价值，w[i]为第i号物品的重量，p[i]为第i号物品的价值。比如：f[2][10],就是从2的个问题（1.2号物品中）找出承重量为3的最优价值，f[2][3]=max(f[1][3],f[1][1]+3)，这里要么选择前一个问题值，要么在满足承重条件下加上2号物品价值，两个选最大的就行了。
**分解的5个子问题：** 1.从1号物品中分别找出背包承重[0，10]的最优解。2.从1.2号物品中分别找出背包承重[0，10]的最优解，很明显从4开始,最优解v=9。3.从1.2.3号物品中分别找出背包承重[0，10]的最优解。4.从1.2.3.4号物品中分别找出背包承重[0，10]的最优解。5.从1.2.3.4.5号物品中分别找出背包承重[0，10]的最优解。
**下表为每个子问题对应承重的最优解** 
| 子问题\承重 | 0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 | 10 |
| :----: | :----: | :----: | :----: | :----: | :----: | :----: | :----: | :----: | :----: | :----: | :----: |
|0| 0 | 0 |0| 0 | 0 |0| 0 | 0 |0| 0 | 0 |
|1| 0 | 0 |6| 6 | 6 |6| 6 | 6 |6| 6 | 6 | 
|2| 0 | 0 |6| 6 | 9 |9| 9 | 9 |9| 9 | 9 |
|3| 0 | 0 |6| 6 | 9 |9| 9 | 9 |11| 11 | 14 |
|4| 0 | 0 |6| 6 | 9 |9| 9 | 10 |11| 13 | 14 |
|5| 0 | 0 |6| 6 | 9 |9| 12 | 12 |15| 15 | 15 |





